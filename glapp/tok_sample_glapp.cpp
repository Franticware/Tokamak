#include "tok_sample_glapp.h"

#include <map>

SampleCamera g_Camera;

std::map<SDL_Keycode, bool> keyboardState;
std::map<SDL_Keycode, bool> keyboardStateOnce;

bool sdlGetAsyncKeyState(SDL_Keycode k)
{
    return keyboardState[k];
}

bool sdlGetAsyncKeyStateOnce(SDL_Keycode k)
{
    bool ret = keyboardStateOnce[k];
    keyboardStateOnce[k] = false;
    return ret;
}

static GLfloat projectionFrustum[16];
static GLfloat projectionOrtho[16];
static GLuint fontTexture = 0;
static const uint32_t fontWidth = 128;
static const uint32_t fontHeight = 64;
static const uint32_t fontCharWidth = 7;
static const uint32_t fontCharHeight = 9;

GLuint InitFont()
{
    // https://opengameart.org/content/pixel-font-basic-latin-latin-1-box-drawing
    static const uint32_t fontData[256]={
        0,0,0,0,0x82850400,0x10103010,2,0x2000,0xc2850400,0x810492b,0x10204,0x2000,0xa7c00400,0x8002890,0x10a84,0x1000,0xc2800400,0x8001041,0xf007c704,0x1001,0x87c00400,0x800a922,0x10a84,0x1000,0xe2800000,
        0x8004a91,0x410204,0x800,0x82800400,0x1000b100,0x400002,0x810,0,0,0x200000,0,0,0,0,0,0x8387041c,0x1c7c71f1,0xe,0x3800,0x44488622,0x22400811,0x1008111,0x4410,0x24080532,0x22200811,0xf0800011,0x4421,
        0xe304042a,0x1c1078f3,0x40001e,0x2040,0x4020426,0x22088901,0xf0800010,0x1021,0x4410422,0x22088901,0x1008110,0x10,0x38f9f1c,0x1c0870f1,0x800e,0x1000,0,0,0x4000,0,0,0,0,0,0xe3878e1c,0x2238f9f1,
        0x10244f9f,0x3889,0x24489122,0x22440812,0xb0244804,0x4489,0x2048913a,0x22040812,0x50224804,0x4499,0x20479f2a,0x3e0478f2,0x1021c804,0x44a9,0x2048913a,0x22640812,0x10224804,0x44c9,0x24489102,0x22440812,
        0x10244884,0x4489,0xe387911c,0x223809f1,0x13e4471f,0x3889,0,0,0,0,0,0,0,0,0xe7878e1e,0x22448913,0x60430f91,0x20,0x80489122,0x22448910,0x40410811,0x50,0x80489122,0x14448910,0x4081040a,0x88,0x8387911e,
        0x8448910,0x40810204,0,0x84089502,0x14548910,0x40810104,0,0x84088902,0x226c5110,0x41010084,0,0x83c89602,0x224420e0,0x61030f84,0x7c00,0,0,0,0,0,0,0,0,0x8004,0x2006002,0x204804,0,0x8008,0x2001002,
        0x204000,0,0xc3878e00,0x1e78f8e3,0xb0224e07,0x3878,0x24489000,0x22441112,0x5021c804,0x4489,0x20489e00,0x224411f2,0x50224804,0x4489,0x24489100,0x22781012,0x11244884,0x4489,0xc3879e00,0x224011e3,
        0x10c4471f,0x3889,0,0x380000,0,0,0,0,0,0,0x40000000,0,0x20820000,0,0x40000000,0,0x40810000,0,0xe7869e1e,0x22448911,0x40810f91,0x10,0x40499122,0x14448910,0x80808411,0xa8,0x43809122,0x8448910,
        0x4081021e,0x40,0x44009e1e,0x14545112,0x40810110,0,0x83c09002,0x222821e1,0x20820f8e,0,0x1002,
        };

    uint8_t fontBuf[fontWidth * fontHeight];

    for (uint32_t y = 0; y != fontHeight; ++y)
    {
        for (uint32_t x = 0; x != fontWidth; ++x)
        {
            fontBuf[x + y * fontWidth] = 255 * !!(fontData[(x / 32) + y * (fontWidth/32)] & (1 << (x & 31)));
        }
    }

    GLuint ret = 0;

    glGenTextures(1, &ret);

    glBindTexture(GL_TEXTURE_2D, ret);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, fontWidth, fontHeight, 0, GL_ALPHA, GL_UNSIGNED_BYTE, fontBuf);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    glBindTexture(GL_TEXTURE_2D, 0);

    return ret;
}

void MyRenderText(const char** str, int count)
{
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(projectionOrtho);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glEnable(GL_TEXTURE_2D);
    glEnable(GL_ALPHA_TEST);
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);
    glBindTexture(GL_TEXTURE_2D, fontTexture);

    glColor3f(1, 1, 0);

    for (int y = 0; y != count; ++y)
    {
        for (size_t x = 0; x != strlen(str[y]); ++x)
        {
            char c = str[y][x];
            if (c < 0) c = 127;
            else if (c < 32) c = 32;
            c -= 32;
            int fx = c % 16;
            int fy = c / 16;
            f32 textScale = 1;
            const f32 texCoords[] = {
                (fx+0)*fontCharWidth*1.f/fontWidth,(fy+0)*fontCharHeight*1.f/fontHeight,
                (fx+0)*fontCharWidth*1.f/fontWidth,(fy+1)*fontCharHeight*1.f/fontHeight,
                (fx+1)*fontCharWidth*1.f/fontWidth,(fy+1)*fontCharHeight*1.f/fontHeight,
                (fx+1)*fontCharWidth*1.f/fontWidth,(fy+0)*fontCharHeight*1.f/fontHeight
                };
            const f32 verts[] = {
                (x+0.51f)*fontCharWidth*textScale,(y+0.51f)*fontCharHeight*textScale,0,
                (x+0.51f)*fontCharWidth*textScale,(y+1.51f)*fontCharHeight*textScale,0,
                (x+1.51f)*fontCharWidth*textScale,(y+1.51f)*fontCharHeight*textScale,0,
                (x+1.51f)*fontCharWidth*textScale,(y+0.51f)*fontCharHeight*textScale,0,
                };

            glEnableClientState(GL_TEXTURE_COORD_ARRAY);
            glTexCoordPointer(2, GL_FLOAT, 0, texCoords);

            glEnableClientState(GL_VERTEX_ARRAY);
            glVertexPointer(3, GL_FLOAT, 0, verts);

            glDrawArrays(GL_QUADS, 0, 4);

            glDisableClientState(GL_VERTEX_ARRAY);
            glDisableClientState(GL_TEXTURE_COORD_ARRAY);
        }
    }
}

CRenderPrimitive::CRenderPrimitive()
{
    mColor[0] = 1.f;
    mColor[1] = 1.f;
    mColor[2] = 1.f;
    mColor[3] = 1.f;
}

void CRenderPrimitive::SetDiffuseColor(f32 r, f32 g, f32 b, f32 a)
{
    mColor[0] = r;
    mColor[1] = g;
    mColor[2] = b;
    mColor[3] = a;
}

void CRenderPrimitive::SetGraphicBox(f32 Width, f32 Height, f32 Depth)
{
    //create the render mesh
    static const f32 boxVerts[] =
    {
        -0.500000,0.500000,0.500000,0.500000,-0.500000,0.500000,0.500000,0.500000,0.500000,0.500000,-0.500000,0.500000,-0.500000,-0.500000,-0.500000,0.500000,-0.500000,-0.500000,-0.500000,-0.500000,0.500000,
            -0.500000,0.500000,-0.500000,-0.500000,-0.500000,-0.500000,0.500000,0.500000,-0.500000,-0.500000,-0.500000,-0.500000,-0.500000,0.500000,-0.500000,0.500000,0.500000,0.500000,0.500000,-0.500000,
            -0.500000,0.500000,0.500000,-0.500000,-0.500000,0.500000,0.500000,0.500000,0.500000,-0.500000,-0.500000,0.500000,-0.500000,-0.500000,-0.500000,0.500000,-0.500000,-0.500000,0.500000,-0.500000,
            0.500000,0.500000,0.500000,-0.500000,-0.500000,0.500000,-0.500000,0.500000,0.500000,0.500000,0.500000,
        };
    static const f32 boxNormals[] =
    {
        0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,
        0.000000,0.000000,-1.000000,0.000000,0.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,1.000000,0.000000,-0.000000,1.000000,0.000000,-0.000000,1.000000,
        0.000000,-0.000000,0.000000,1.000000,-0.000000,0.000000,1.000000,-0.000000,0.000000,1.000000,-0.000000,0.000000,-0.000000,1.000000,0.000000,-1.000000,0.000000,-1.000000,0.000000,0.000000,0.000000,
        0.000000,-1.000000,1.000000,0.000000,0.000000,0.000000,1.000000,-0.000000,
    };
    static const uint16_t boxTris[] =
    {
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0,18,1,3,19,4,6,20,7,9,21,10,12,22,13,15,23,16,
    };

    mTris.assign(boxTris, boxTris + sizeof(boxTris)/sizeof(uint16_t));

    mVerts.clear();
    mNormals.clear();

    mVerts.resize(sizeof(boxVerts)/sizeof(f32));
    mNormals.resize(sizeof(boxNormals)/sizeof(f32));

    for (int i = 0; i != sizeof(boxVerts)/sizeof(f32)/3; ++i)
    {
        mVerts[i * 3 + 0] = boxVerts[i * 3 + 0] * Width;
        mVerts[i * 3 + 1] = boxVerts[i * 3 + 1] * Height;
        mVerts[i * 3 + 2] = boxVerts[i * 3 + 2] * Depth;

        mNormals[i * 3 + 0] = boxNormals[i * 3 + 0];
        mNormals[i * 3 + 1] = boxNormals[i * 3 + 1];
        mNormals[i * 3 + 2] = boxNormals[i * 3 + 2];
    }
}

void CRenderPrimitive::SetGraphicSphere(f32 radius)
{
    static const f32 sphereVerts[] =
    {
        0.000000,0.000000,-1.000000,0.203181,-0.147618,-0.967950,-0.077607,-0.238853,-0.967950,0.723607,-0.525725,-0.447220,0.609547,-0.442856,-0.657519,0.812729,-0.295238,-0.502301,-0.251147,0.000000,-0.967949,-0.077607,0.238853,-0.967950,0.203181,0.147618,-0.967950,0.860698,-0.442858,-0.251151,-0.276388,-0.850649,
        -0.447220,-0.029639,-0.864184,-0.502302,-0.155215,-0.955422,-0.251152,-0.894426,0.000000,-0.447216,-0.831051,-0.238853,-0.502299,-0.956626,-0.147618,-0.251149,-0.276388,0.850649,-0.447220,-0.483971,0.716565,-0.502302,-0.436007,0.864188,-0.251152,0.723607,0.525725,-0.447220,0.531941,0.681712,-0.502302,0.687159,
        0.681715,-0.251152,0.687159,-0.681715,-0.251152,-0.436007,-0.864188,-0.251152,-0.956626,0.147618,-0.251149,-0.155215,0.955422,-0.251152,0.860698,0.442858,-0.251151,0.276388,-0.850649,0.447220,0.483971,-0.716565,0.502302,0.232822,-0.716563,0.657519,-0.723607,-0.525725,0.447220,-0.531941,-0.681712,0.502302,
        -0.609547,-0.442856,0.657519,-0.723607,0.525725,0.447220,-0.812729,0.295238,0.502301,-0.609547,0.442856,0.657519,0.276388,0.850649,0.447220,0.029639,0.864184,0.502302,0.232822,0.716563,0.657519,0.894426,0.000000,0.447216,0.831051,0.238853,0.502299,0.753442,0.000000,0.657515,0.251147,0.000000,0.967949,0.077607,
        0.238853,0.967950,0.000000,0.000000,1.000000,0.525730,0.000000,0.850652,0.361800,0.262863,0.894429,0.638194,0.262864,0.723610,0.162456,0.499995,0.850654,0.447209,0.525728,0.723612,0.688189,0.499997,0.525736,0.483971,0.716565,0.502302,-0.203181,0.147618,0.967950,-0.138197,0.425319,0.894430,-0.052790,0.688185,
        0.723612,-0.425323,0.309011,0.850654,-0.361804,0.587778,0.723612,-0.262869,0.809012,0.525738,-0.531941,0.681712,0.502302,-0.203181,-0.147618,0.967950,-0.447210,0.000000,0.894429,-0.670817,0.162457,0.723611,-0.425323,-0.309011,0.850654,-0.670817,-0.162457,0.723611,-0.850648,0.000000,0.525736,-0.812729,-0.295238,
        0.502301,0.077607,-0.238853,0.967950,-0.138197,-0.425319,0.894430,-0.361804,-0.587778,0.723612,0.162456,-0.499995,0.850654,-0.052790,-0.688185,0.723612,-0.262869,-0.809012,0.525738,0.029639,-0.864184,0.502302,0.361800,-0.262863,0.894429,0.447209,-0.525728,0.723612,0.638194,-0.262864,0.723610,0.688189,-0.499997,
        0.525736,0.831051,-0.238853,0.502299,0.956626,0.147618,0.251149,0.951058,0.309013,0.000000,0.861804,0.425322,0.276396,0.809019,0.587782,0.000000,0.670821,0.688189,0.276397,0.587786,0.809017,-0.000000,0.436007,0.864188,0.251152,0.155215,0.955422,0.251152,0.000000,1.000000,0.000000,-0.138199,0.951055,0.276397,
        -0.309016,0.951057,-0.000000,-0.447215,0.850649,0.276397,-0.587786,0.809017,-0.000000,-0.687159,0.681715,0.251152,-0.860698,0.442858,0.251151,-0.951058,0.309013,0.000000,-0.947213,0.162458,0.276396,-1.000000,-0.000000,0.000001,-0.947213,-0.162458,0.276397,-0.951058,-0.309013,-0.000000,-0.860698,-0.442858,
        0.251151,-0.687159,-0.681715,0.251152,-0.587786,-0.809017,0.000000,-0.447216,-0.850648,0.276397,-0.309017,-0.951056,-0.000001,-0.138199,-0.951055,0.276397,0.000000,-1.000000,-0.000000,0.155215,-0.955422,0.251152,0.436007,-0.864188,0.251152,0.587786,-0.809017,0.000000,0.670820,-0.688190,0.276396,0.809019,
        -0.587783,-0.000002,0.861804,-0.425323,0.276394,0.951058,-0.309013,-0.000000,0.956626,-0.147618,0.251149,0.309017,0.951056,-0.000000,0.447216,0.850648,-0.276398,0.138199,0.951055,-0.276398,0.262869,0.809012,-0.525738,-0.029639,0.864184,-0.502302,-0.809018,0.587783,-0.000000,-0.670819,0.688191,-0.276397,
        -0.861803,0.425324,-0.276396,-0.688189,0.499997,-0.525736,-0.831051,0.238853,-0.502299,-0.809018,-0.587783,0.000000,-0.861803,-0.425324,-0.276396,-0.670819,-0.688191,-0.276397,-0.688189,-0.499997,-0.525736,-0.483971,-0.716565,-0.502302,0.309017,-0.951056,0.000000,0.138199,-0.951055,-0.276398,0.447216,-0.850648,
        -0.276398,0.262869,-0.809012,-0.525738,0.531941,-0.681712,-0.502302,1.000000,0.000000,0.000000,0.947213,-0.162458,-0.276396,0.947213,0.162458,-0.276396,0.850648,0.000000,-0.525736,0.812729,0.295238,-0.502301,0.609547,0.442856,-0.657519,0.425323,0.309011,-0.850654,0.361803,0.587779,-0.723612,0.138197,0.425321,
        -0.894429,0.052789,0.688186,-0.723611,-0.162456,0.499995,-0.850654,-0.232822,0.716563,-0.657519,-0.447211,0.525727,-0.723612,-0.361801,0.262863,-0.894429,-0.638195,0.262863,-0.723609,-0.525730,0.000000,-0.850652,-0.753442,0.000000,-0.657515,-0.638195,-0.262864,-0.723609,-0.361801,-0.262864,-0.894428,-0.447211,
        -0.525729,-0.723610,-0.162456,-0.499995,-0.850654,-0.232822,-0.716563,-0.657519,0.670817,0.162457,-0.723611,0.670818,-0.162458,-0.723610,0.447211,-0.000001,-0.894428,0.425323,-0.309011,-0.850654,0.052790,-0.688185,-0.723612,0.138199,-0.425321,-0.894429,0.361805,-0.587779,-0.723611,
    };
    static const uint16_t sphereTris[] =
    {
        0,1,2,3,4,5,0,2,6,0,6,7,0,7,8,3,5,9,10,11,12,13,14,15,16,17,18,19,20,21,3,9,22,10,12,23,13,15,24,16,18,25,19,21,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,42,41,47,45,42,46,43,46,48,43,45,47,46,47,49,46,46,49,48,49,38,48,41,40,47,40,50,47,47,50,49,50,51,49,49,51,38,51,36,38,43,52,44,48,53,
        43,38,54,48,43,53,52,53,55,52,48,54,53,54,56,53,53,56,55,56,35,55,38,37,54,37,57,54,54,57,56,57,58,56,56,58,35,58,33,35,52,59,44,55,60,52,35,61,55,52,60,59,60,62,59,55,61,60,61,63,60,60,63,62,63,32,62,35,34,61,34,64,61,61,64,63,64,65,63,63,65,32,65,30,32,59,66,44,62,67,59,32,68,62,59,67,66,67,69,66,62,68,67,
        68,70,67,67,70,69,70,29,69,32,31,68,31,71,68,68,71,70,71,72,70,70,72,29,72,27,29,66,42,44,69,73,66,29,74,69,66,73,42,73,45,42,69,74,73,74,75,73,73,75,45,75,41,45,29,28,74,28,76,74,74,76,75,76,77,75,75,77,41,77,39,41,78,40,39,79,80,78,26,81,79,78,80,40,80,50,40,79,81,80,81,82,80,80,82,50,82,51,50,26,21,81,21,
        83,81,81,83,82,83,84,82,82,84,51,84,36,51,85,37,36,86,87,85,25,88,86,85,87,37,87,57,37,86,88,87,88,89,87,87,89,57,89,58,57,25,18,88,18,90,88,88,90,89,90,91,89,89,91,58,91,33,58,92,34,33,93,94,92,24,95,93,92,94,34,94,64,34,93,95,94,95,96,94,94,96,64,96,65,64,24,15,95,15,97,95,95,97,96,97,98,96,96,98,65,98,30,
        65,99,31,30,100,101,99,23,102,100,99,101,31,101,71,31,100,102,101,102,103,101,101,103,71,103,72,71,23,12,102,12,104,102,102,104,103,104,105,103,103,105,72,105,27,72,106,28,27,107,108,106,22,109,107,106,108,28,108,76,28,107,109,108,109,110,108,108,110,76,110,77,76,22,9,109,9,111,109,109,111,110,111,112,110,
        110,112,77,112,39,77,84,85,36,83,113,84,21,114,83,84,113,85,113,86,85,83,114,113,114,115,113,113,115,86,115,25,86,21,20,114,20,116,114,114,116,115,116,117,115,115,117,25,117,16,25,91,92,33,90,118,91,18,119,90,91,118,92,118,93,92,90,119,118,119,120,118,118,120,93,120,24,93,18,17,119,17,121,119,119,121,120,121,
        122,120,120,122,24,122,13,24,98,99,30,97,123,98,15,124,97,98,123,99,123,100,99,97,124,123,124,125,123,123,125,100,125,23,100,15,14,124,14,126,124,124,126,125,126,127,125,125,127,23,127,10,23,105,106,27,104,128,105,12,129,104,105,128,106,128,107,106,104,129,128,129,130,128,128,130,107,130,22,107,12,11,129,11,
        131,129,129,131,130,131,132,130,130,132,22,132,3,22,112,78,39,111,133,112,9,134,111,112,133,78,133,79,78,111,134,133,134,135,133,133,135,79,135,26,79,9,5,134,5,136,134,134,136,135,136,137,135,135,137,26,137,19,26,138,20,19,139,140,138,8,141,139,138,140,20,140,116,20,139,141,140,141,142,140,140,142,116,142,117,
        116,8,7,141,7,143,141,141,143,142,143,144,142,142,144,117,144,16,117,144,17,16,143,145,144,7,146,143,144,145,17,145,121,17,143,146,145,146,147,145,145,147,121,147,122,121,7,6,146,6,148,146,146,148,147,148,149,147,147,149,122,149,13,122,149,14,13,148,150,149,6,151,148,149,150,14,150,126,14,148,151,150,151,152,
        150,150,152,126,152,127,126,6,2,151,2,153,151,151,153,152,153,154,152,152,154,127,154,10,127,137,138,19,136,155,137,5,156,136,137,155,138,155,139,138,136,156,155,156,157,155,155,157,139,157,8,139,5,4,156,4,158,156,156,158,157,158,1,157,157,1,8,1,0,8,154,11,10,153,159,154,2,160,153,154,159,11,159,131,11,153,160,
        159,160,161,159,159,161,131,161,132,131,2,1,160,1,158,160,160,158,161,158,4,161,161,4,132,4,3,132,
    };

    mTris.assign(sphereTris, sphereTris + sizeof(sphereTris)/sizeof(uint16_t));

    mVerts.clear();
    mNormals.clear();

    mVerts.resize(sizeof(sphereVerts)/sizeof(f32));
    mNormals.resize(sizeof(sphereVerts)/sizeof(f32));

    for (int i = 0; i != sizeof(sphereVerts)/sizeof(f32)/3; ++i)
    {
        mVerts[i * 3 + 0] = sphereVerts[i * 3 + 0] * radius;
        mVerts[i * 3 + 1] = sphereVerts[i * 3 + 1] * radius;
        mVerts[i * 3 + 2] = sphereVerts[i * 3 + 2] * radius;

        mNormals[i * 3 + 0] = sphereVerts[i * 3 + 0];
        mNormals[i * 3 + 1] = sphereVerts[i * 3 + 1];
        mNormals[i * 3 + 2] = sphereVerts[i * 3 + 2];
    }
}

void CRenderPrimitive::SetGraphicCylinder(f32 radius, f32 length)
{
    static const f32 cylVerts[] =
    {
        0.000000,0.500000,-1.000000,0.382683,-0.500000,-0.923880,0.000000,-0.500000,-1.000000,0.382683,0.500000,-0.923879,0.707107,-0.500000,-0.707107,0.707107,0.500000,-0.707107,0.923880,-0.500000,-0.382683,
        0.923880,0.500000,-0.382683,1.000000,-0.500000,0.000000,1.000000,0.500000,0.000000,0.923880,-0.500000,0.382683,0.923880,0.500000,0.382683,0.707107,-0.500000,0.707107,0.707107,0.500000,0.707107,
        0.382683,-0.500000,0.923879,0.382683,0.500000,0.923880,-0.000000,-0.500000,1.000000,-0.000000,0.500000,1.000000,-0.382683,-0.500000,0.923879,-0.382683,0.500000,0.923880,-0.707107,-0.500000,0.707107,
        -0.707107,0.500000,0.707107,-0.923880,-0.500000,0.382684,-0.923880,0.500000,0.382684,-1.000000,-0.500000,-0.000000,-1.000000,0.500000,0.000000,-0.923879,-0.500000,-0.382684,-0.923879,0.500000,
        -0.382684,-0.707107,-0.500000,-0.707107,-0.000000,0.500000,1.000000,0.707107,0.500000,0.707107,0.707107,0.500000,-0.707107,-0.707107,0.500000,-0.707107,-0.382683,-0.500000,-0.923880,-0.382683,
        0.500000,-0.923880,0.923880,-0.500000,-0.382683,0.382683,-0.500000,0.923879,-0.923880,-0.500000,0.382684,0.382683,0.500000,-0.923879,0.000000,0.500000,-1.000000,-0.382683,0.500000,-0.923880,
        -0.707107,0.500000,-0.707107,-0.923879,0.500000,-0.382684,-1.000000,0.500000,0.000000,-0.923880,0.500000,0.382684,-0.707107,0.500000,0.707107,-0.382683,0.500000,0.923880,0.382683,0.500000,0.923880,
        0.923880,0.500000,0.382683,1.000000,0.500000,0.000000,0.923880,0.500000,-0.382683,-0.382683,-0.500000,-0.923880,0.000000,-0.500000,-1.000000,0.382683,-0.500000,-0.923880,0.707107,-0.500000,-0.707107,
        1.000000,-0.500000,0.000000,0.923880,-0.500000,0.382683,0.707107,-0.500000,0.707107,-0.000000,-0.500000,1.000000,-0.382683,-0.500000,0.923879,-0.707107,-0.500000,0.707107,-1.000000,-0.500000,
        -0.000000,-0.923879,-0.500000,-0.382684,-0.707107,-0.500000,-0.707107,
    };
    static const f32 cylNormals[] =
    {
        0.000000,0.000000,-1.000000,0.382672,0.000000,-0.923856,0.000000,0.000000,-1.000000,0.382672,0.000000,-0.923856,0.707083,0.000000,-0.707083,0.707083,0.000000,-0.707083,0.923856,0.000000,-0.382672,
        0.923856,0.000000,-0.382672,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.923856,0.000000,0.382672,0.923856,0.000000,0.382672,0.707083,0.000000,0.707083,0.707083,0.000000,0.707083,0.382672,
        0.000000,0.923856,0.382672,0.000000,0.923856,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,-0.382672,0.000000,0.923856,-0.382672,0.000000,0.923856,-0.707083,0.000000,0.707083,-0.707083,
        0.000000,0.707083,-0.923856,0.000000,0.382672,-0.923856,0.000000,0.382672,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-0.923856,0.000000,-0.382672,-0.923856,0.000000,-0.382672,-0.707083,
        0.000000,-0.707083,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,-0.707083,0.000000,-0.707083,-0.382672,0.000000,-0.923856,-0.382672,0.000000,-0.923856,0.000000,
        -1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,
        1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,
        1.000000,0.000000,0.000000,1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,
        -1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,-1.000000,0.000000,0.000000,
        -1.000000,0.000000,
    };
    static const uint16_t cylTris[] =
    {
        0,1,2,3,4,1,5,6,4,7,8,6,9,10,8,11,12,10,13,14,12,15,16,14,17,18,16,19,20,18,21,22,20,23,24,22,25,26,24,27,28,26,29,30,31,32,33,28,34,2,33,35,36,37,0,3,1,3,5,4,5,7,6,7,9,8,9,11,10,11,13,12,13,15,14,15,17,
        16,17,19,18,19,21,20,21,23,22,23,25,24,25,27,26,27,32,28,31,38,39,39,40,41,41,42,43,43,44,45,45,46,29,29,47,30,30,48,49,49,50,30,50,31,30,31,39,41,41,43,31,43,45,31,45,29,31,32,34,33,34,0,2,51,52,35,
        52,53,35,53,54,35,35,55,56,56,57,36,36,58,59,59,60,37,37,61,62,62,63,37,63,51,37,35,56,36,36,59,37,51,35,37,
    };

    mTris.assign(cylTris, cylTris + sizeof(cylTris)/sizeof(uint16_t));

    mVerts.clear();
    mNormals.clear();

    mVerts.resize(sizeof(cylVerts)/sizeof(f32));
    mNormals.resize(sizeof(cylVerts)/sizeof(f32));

    for (int i = 0; i != sizeof(cylVerts)/sizeof(f32)/3; ++i)
    {
        mVerts[i * 3 + 0] = cylVerts[i * 3 + 0] * radius;
        mVerts[i * 3 + 1] = cylVerts[i * 3 + 1] * length;
        mVerts[i * 3 + 2] = cylVerts[i * 3 + 2] * radius;

        mNormals[i * 3 + 0] = cylNormals[i * 3 + 0];
        mNormals[i * 3 + 1] = cylNormals[i * 3 + 1];
        mNormals[i * 3 + 2] = cylNormals[i * 3 + 2];
    }
}

void CRenderPrimitive::SetGraphicMesh(const char* strFilename)
{
    (void)strFilename;
    // loading of *.x not implemented
}

void CRenderPrimitive::SetGraphicMesh(const f32* vert, int vertCount, const f32* norm, int normCount, const uint16_t* ind, int indCount, int prim)
{
    mTris.clear();
    for (int i = 0; i != indCount/prim; ++i)
    {
        if (prim >= 3)
        {
            mTris.push_back(ind[i*prim+0]);
            mTris.push_back(ind[i*prim+1]);
            mTris.push_back(ind[i*prim+2]);
        }
        if (prim == 4)
        {
            mTris.push_back(ind[i*prim+0]);
            mTris.push_back(ind[i*prim+2]);
            mTris.push_back(ind[i*prim+3]);
        }
    }

    mVerts.assign(vert, vert + vertCount*3);
    mNormals.assign(norm, norm + normCount * 3);
}

void CRenderPrimitive::Render(const neT3 * matrix)
{
    if (mTris.empty())
    {
        return;
    }

    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(projectionFrustum);
    glMatrixMode(GL_MODELVIEW);

    glDisable(GL_TEXTURE_2D);
    glDisable(GL_ALPHA_TEST);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);

    neT3 ct = g_Camera.GetViewMatrix();

    f32 gl_Matrix[16];
    toGlMatrix(gl_Matrix, ct);
    glLoadMatrixf(gl_Matrix);

    for (int i = 0; i != NUM_LIGHT; ++i)
    {
        glLightfv(GL_LIGHT0 + i, GL_POSITION, &(vLightWorld[i].X));
        glLightfv(GL_LIGHT0 + i, GL_DIFFUSE, &(vLightColor[i].X));
    }

    glMaterialfv(GL_FRONT, GL_DIFFUSE, mColor);

    toGlMatrix(gl_Matrix, *matrix);
    glMultMatrixf(gl_Matrix);

    glEnableClientState(GL_NORMAL_ARRAY);
    glNormalPointer(GL_FLOAT, 0, &mNormals[0]);

    glEnableClientState(GL_VERTEX_ARRAY);
    glVertexPointer(3, GL_FLOAT, 0, &mVerts[0]);

    glDrawElements(GL_TRIANGLES, mTris.size(), GL_UNSIGNED_SHORT, &mTris[0]);

    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_NORMAL_ARRAY);
}

int main(int argc, char** argv)
{
    (void)argc;
    (void)argv;
    SDL_Window *mainwindow; // Our window handle
    SDL_GLContext maincontext; // Our opengl context handle

    SDL_Init(SDL_INIT_VIDEO);

    SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);

    // Turn on double buffering with a 24bit Z buffer.
    // You may need to change this to 16 or 32 for your system
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);

    int width = 800, height = 600;

    // Create our window centered
    mainwindow = SDL_CreateWindow(tokamakSampleTitle, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                                  width, height, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);

    if (!mainwindow)
    {
        // Die if creation failed
        printf("SDL Error: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // Create our opengl context and attach it to our window
    maincontext = SDL_GL_CreateContext(mainwindow);

    MyAppInit();

    // This makes our buffer swap syncronized with the monitor's vertical refresh
    SDL_GL_SetSwapInterval(1);

    fontTexture = InitFont();

    glClearColor(45.f/255.f, 50.f/255.f, 170.f/255.f, 1.f);
    glAlphaFunc(GL_GREATER, 0.5f);

    glMatrixMode(GL_PROJECTION);

    const f32 aspect = width/height;
    f32 near = 1;
    f32 far = 500;
    f32 atanFov = std::atan(60.f * 0.5f * M_PI/180.f);
    glLoadIdentity();
    glFrustum(atanFov*near*(-1), atanFov*near*1, -atanFov*near/(aspect), atanFov*near/(aspect), near, far);
    glGetFloatv(GL_PROJECTION_MATRIX, projectionFrustum);

    glLoadIdentity();
    glOrtho(0, width, height, 0, -1, 1);
    glGetFloatv(GL_PROJECTION_MATRIX, projectionOrtho);

    glMatrixMode(GL_MODELVIEW);
    glEnable(GL_CULL_FACE);

    for (int i = 0; i != NUM_LIGHT; ++i)
    {
        glEnable(GL_LIGHT0 + i);
    }

    bool gQuit = false;
    while (true)
    {
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            switch (event.type)
            {
            case SDL_QUIT:
                gQuit = true;
                break;
            case SDL_KEYDOWN:
            {
                MyAppKeyboardProc(event.key.keysym.sym, true, event.key.keysym.mod & KMOD_ALT);
                if (!keyboardState[event.key.keysym.sym])
                {
                    keyboardStateOnce[event.key.keysym.sym] = true;
                }
                keyboardState[event.key.keysym.sym] = true;
                if (event.key.keysym.sym == SDLK_ESCAPE)
                {
                    gQuit = true;
                }
                break;
            }
            case SDL_KEYUP:
            {
                MyAppKeyboardProc(event.key.keysym.sym, false, event.key.keysym.mod & KMOD_ALT);
                keyboardState[event.key.keysym.sym] = false;
                keyboardStateOnce[event.key.keysym.sym] = false;
                break;
            }
            }
        }
        if (gQuit)
        {
            break;
        }

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        OnMyAppFrameMove(0, 0);
        OnMyAppFrameRender();

        SDL_GL_SwapWindow(mainwindow);
    }

    OnMyAppDestroyDevice();

    // Delete our opengl context, destroy our window, and shutdown SDL
    SDL_GL_DeleteContext(maincontext);
    SDL_DestroyWindow(mainwindow);
    SDL_Quit();
    return 0;
}
